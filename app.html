<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Qubit Visualizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            color: #e0e0e0;
            background-color: #1a1a1a;
        }
        .control-panel {
            background-color: rgba(42, 42, 42, 0.8);
            backdrop-filter: blur(10px);
        }
        .btn {
            transition: all 0.3s ease;
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }
        #visualization-container {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            z-index: -1;
        }
        canvas {
            display: block;
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
</head>
<body class="overflow-hidden">
    <div id="visualization-container"></div>
    <div class="absolute top-0 left-0 p-4 md:p-6 w-full md:w-auto">
        <div class="control-panel p-4 rounded-lg shadow-2xl">
            <h1 class="text-2xl font-bold text-white mb-4">Multi-Qubit Visualizer</h1>
            <!-- Qubit Controls -->
            <div class="flex items-center space-x-4 mb-4">
                <label class="font-medium text-lg">Qubits:</label>
                <button id="remove-qubit" class="btn bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg">-</button>
                <span id="qubit-count" class="text-xl font-semibold w-8 text-center">1</span>
                <button id="add-qubit" class="btn bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg">+</button>
            </div>
            <!-- Gate Controls -->
            <div class="grid grid-cols-2 sm:grid-cols-3 gap-3">
                <div>
                    <label for="gate-select" class="block mb-2 text-sm font-medium">Gate:</label>
                    <select id="gate-select" class="bg-gray-700 border border-gray-600 text-white text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5">
                        <option>H</option>
                        <option>X</option>
                        <option>Y</option>
                        <option>Z</option>
                        <option>CNOT</option>
                    </select>
                </div>
                <div>
                    <label for="target-qubit" class="block mb-2 text-sm font-medium">Target:</label>
                    <select id="target-qubit" class="bg-gray-700 border border-gray-600 text-white text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5">
                        <option value="0">0</option>
                    </select>
                </div>
                <div id="control-qubit-container" class="hidden">
                    <label for="control-qubit" class="block mb-2 text-sm font-medium">Control:</label>
                    <select id="control-qubit" class="bg-gray-700 border border-gray-600 text-white text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5">
                    </select>
                </div>
                <div class="col-span-full">
                    <button id="apply-gate" class="btn w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg">Apply Gate</button>
                </div>
            </div>
        </div>
    </div>
    <!-- State Vector Display -->
    <div class="absolute bottom-0 left-0 p-4 md:p-6 w-full">
        <div class="control-panel p-4 rounded-lg shadow-2xl max-h-48 overflow-y-auto">
            <h2 class="text-lg font-semibold mb-2">State Vector</h2>
            <div id="state-vector" class="text-sm font-mono whitespace-pre"></div>
        </div>
    </div>
    <script>
        // --- Complex Number Library ---
        class Complex {
            constructor(re = 0, im = 0) {
                this.re = re;
                this.im = im;
            }
            add(other) {
                return new Complex(this.re + other.re, this.im + other.im);
            }
            sub(other) {
                return new Complex(this.re - other.re, this.im - other.im);
            }
            mul(other) {
                const re = this.re * other.re - this.im * other.im;
                const im = this.re * other.im + this.im * other.re;
                return new Complex(re, im);
            }
            abs() {
                return Math.sqrt(this.re * this.re + this.im * this.im);
            }
            toString() {
                const reStr = this.re.toFixed(3);
                const imStr = this.im.toFixed(3);
                if (Math.abs(this.im) < 1e-9) return `${reStr}`;
                if (Math.abs(this.re) < 1e-9) return `${imStr}i`;
                return `${reStr} ${this.im > 0 ? '+' : '-'} ${Math.abs(imStr)}i`;
            }
        }
        const C_ZERO = new Complex(0, 0);
        const C_ONE = new Complex(1, 0);
        // --- Quantum State and Gates ---
        let numQubits = 1;
        let stateVector = [C_ONE, C_ZERO]; // Initial state |0>
        const GATES = {
            H: [
                [new Complex(1 / Math.sqrt(2)), new Complex(1 / Math.sqrt(2))],
                [new Complex(1 / Math.sqrt(2)), new Complex(-1 / Math.sqrt(2))]
            ],
            X: [
                [C_ZERO, C_ONE],
                [C_ONE, C_ZERO]
            ],
            Y: [
                [C_ZERO, new Complex(0, -1)],
                [new Complex(0, 1), C_ZERO]
            ],
            Z: [
                [C_ONE, C_ZERO],
                [C_ZERO, new Complex(-1, 0)]
            ]
        };
        function applySingleQubitGate(gate, target) {
            const newState = new Array(stateVector.length).fill(C_ZERO);
            const k = numQubits - 1 - target;
            for (let i = 0; i < stateVector.length; i++) {
                const bit = (i >> k) & 1;
                const base = i & ~(1 << k);
                const targetState0 = base | (0 << k);
                const targetState1 = base | (1 << k);
                const alpha = stateVector[targetState0];
                const beta = stateVector[targetState1];
                if (bit === 0) {
                    newState[i] = gate[0][0].mul(alpha).add(gate[0][1].mul(beta));
                } else {
                    newState[i] = gate[1][0].mul(alpha).add(gate[1][1].mul(beta));
                }
            }
            stateVector = newState;
        }
        function applyCNOT(control, target) {
            const newState = new Array(stateVector.length).fill(C_ZERO);
            const controlMask = 1 << (numQubits - 1 - control);
            const targetMask = 1 << (numQubits - 1 - target);
            for (let i = 0; i < stateVector.length; i++) {
                if ((i & controlMask) !== 0) { // If control bit is 1
                    const targetBit = (i & targetMask) !== 0;
                    const swappedIndex = i ^ targetMask; // Flip the target bit
                    newState[i] = stateVector[swappedIndex];
                } else { // If control bit is 0
                    newState[i] = stateVector[i];
                }
            }
            stateVector = newState;
        }
        function getBlochVector(qubitIndex) {
            const k = numQubits - 1 - qubitIndex;
            let alpha = C_ZERO;
            let beta = C_ZERO;
            for (let i = 0; i < stateVector.length; i++) {
                if (((i >> k) & 1) === 0) {
                    alpha = alpha.add(stateVector[i]);
                } else {
                    beta = beta.add(stateVector[i]);
                }
            }
            // This is a simplification for visualization.
            // For a pure state, we can find representative alpha/beta.
            // For entangled states, this shows a projection.
            // We need to find the reduced density matrix to be fully correct,
            // but for many common states, this direct calculation works for visualization.
            // Let's find the probability of being |0> and |1> for this qubit
            let prob0 = 0;
            let prob1 = 0;
            for (let i = 0; i < stateVector.length; i++) {
                const amp = stateVector[i];
                const prob = amp.re * amp.re + amp.im * amp.im;
                if (((i >> k) & 1) === 0) {
                    prob0 += prob;
                } else {
                    prob1 += prob;
                }
            }
            // A simplified visualization based on probabilities.
            // A full Bloch vector calculation from the reduced density matrix is more complex.
            // This gives a good intuition for separable states.
            const theta = 2 * Math.acos(Math.sqrt(prob0));
            const phi = 0; // Phase information is lost in this simplification.
            const x = Math.sin(theta) * Math.cos(phi);
            const y = Math.sin(theta) * Math.sin(phi);
            const z = Math.cos(theta);
            return new THREE.Vector3(x, y, z);
        }
        // --- Three.js Visualization ---
        let scene, camera, renderer, controls;
        const blochSpheres = [];
        function init() {
            const container = document.getElementById('visualization-container');
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);
            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);
            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            window.addEventListener('resize', onWindowResize, false);
            updateVisualization();
            animate();
        }
        function createBlochSphere(index) {
            const group = new THREE.Group();
            // Sphere
            const geometry = new THREE.SphereGeometry(1, 32, 32);
            const material = new THREE.MeshPhongMaterial({
                color: 0x4a90e2,
                transparent: true,
                opacity: 0.2,
                shininess: 50
            });
            const sphere = new THREE.Mesh(geometry, material);
            group.add(sphere);
            // Axes
            const axisMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 });
            const axes = ['x', 'y', 'z'];
            axes.forEach(axis => {
                const points = [];
                points.push(new THREE.Vector3(axis === 'x' ? -1.2 : 0, axis === 'y' ? -1.2 : 0, axis === 'z' ? -1.2 : 0));
                points.push(new THREE.Vector3(axis === 'x' ? 1.2 : 0, axis === 'y' ? 1.2 : 0, axis === 'z' ? 1.2 : 0));
                const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), axisMaterial);
                group.add(line);
            });
            // Equator
            const equatorMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.3 });
            const equatorPoints = [];
            for (let i = 0; i <= 360; i++) {
                const rad = i * Math.PI / 180;
                equatorPoints.push(new THREE.Vector3(Math.cos(rad), 0, Math.sin(rad)));
            }
            const equator = new THREE.Line(new THREE.BufferGeometry().setFromPoints(equatorPoints), equatorMaterial);
            group.add(equator);
            // State Vector Arrow
            const arrowOrigin = new THREE.Vector3(0, 0, 0);
            const arrowDir = new THREE.Vector3(0, 0, 1);
            const arrow = new THREE.ArrowHelper(arrowDir, arrowOrigin, 1, 0xffd700, 0.2, 0.1);
            group.arrow = arrow; // Attach for easy access
            group.add(arrow);
            // Qubit Label
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 128;
            context.font = "Bold 48px Arial";
            context.fillStyle = "rgba(255,255,255,0.9)";
            context.textAlign = "center";
            context.textBaseline = "middle";
            const text = `|q${index}⟩`;
            context.fillText(text, canvas.width/2, canvas.height/2);
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(1.0, 0.5, 1.0);
            sprite.position.set(0, 1.4, 0);
            group.add(sprite);
            group.labelSprite = sprite;

            return group;
        }
        function updateVisualization() {
            // Clear existing spheres
            blochSpheres.forEach(sphere => scene.remove(sphere));
            blochSpheres.length = 0;
            // Create and position new spheres
            const spacing = 3;
            const offset = (numQubits - 1) * spacing / 2;
            for (let i = 0; i < numQubits; i++) {
                const sphere = createBlochSphere(i);
                sphere.position.x = i * spacing - offset;
                scene.add(sphere);
                blochSpheres.push(sphere);
            }
            updateState();
        }
        function updateState() {
            // Update arrows
            for (let i = 0; i < numQubits; i++) {
                const blochVector = getBlochVector(i);
                blochSpheres[i].arrow.setDirection(blochVector);
            }
            // Update state vector display
            const stateDiv = document.getElementById('state-vector');
            stateDiv.innerHTML = '';
            for(let i = 0; i < stateVector.length; i++) {
                const basis = i.toString(2).padStart(numQubits, '0');
                const amp = stateVector[i];
                if (amp.abs() > 1e-9) {
                    const prob = (amp.re * amp.re + amp.im * amp.im).toFixed(3);
                    stateDiv.innerHTML += `(${amp.toString()}) |${basis}⟩ (prob: ${prob})\n`;
                }
            }
        }
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        // --- UI Event Listeners ---
        document.getElementById('add-qubit').addEventListener('click', () => {
            if (numQubits < 5) { // Limit for performance
                numQubits++;
                const newSize = Math.pow(2, numQubits);
                const newState = new Array(newSize).fill(C_ZERO);
                // State becomes |0> tensor oldState
                for(let i=0; i < stateVector.length; i++) {
                    newState[i] = stateVector[i];
                }
                stateVector = newState;
                updateUI();
                updateVisualization();
            }
        });
        document.getElementById('remove-qubit').addEventListener('click', () => {
            if (numQubits > 1) {
                numQubits--;
                // This is a simplification: we reset the state
                const newSize = Math.pow(2, numQubits);
                stateVector = new Array(newSize).fill(C_ZERO);
                stateVector[0] = C_ONE;
                updateUI();
                updateVisualization();
            }
        });
        document.getElementById('apply-gate').addEventListener('click', () => {
            const gateName = document.getElementById('gate-select').value;
            const target = parseInt(document.getElementById('target-qubit').value);
            if (gateName === 'CNOT') {
                const control = parseInt(document.getElementById('control-qubit').value);
                if (control !== target) {
                    applyCNOT(control, target);
                } else {
                    // Simple feedback, ideally a modal
                    console.error("Control and target qubits cannot be the same.");
                    return;
                }
            } else {
                applySingleQubitGate(GATES[gateName], target);
            }
            updateState();
        });
        document.getElementById('gate-select').addEventListener('change', (e) => {
            const controlContainer = document.getElementById('control-qubit-container');
            if (e.target.value === 'CNOT') {
                controlContainer.classList.remove('hidden');
            } else {
                controlContainer.classList.add('hidden');
            }
        });
        function updateUI() {
            document.getElementById('qubit-count').textContent = numQubits;
            const targetSelect = document.getElementById('target-qubit');
            const controlSelect = document.getElementById('control-qubit');
            targetSelect.innerHTML = '';
            controlSelect.innerHTML = '';
            for (let i = 0; i < numQubits; i++) {
                const option = `<option value="${i}">${i}</option>`;
                targetSelect.innerHTML += option;
                controlSelect.innerHTML += option;
            }
        }
        // Initial setup
        init();
        updateUI();
    </script>
</body>

</html>
